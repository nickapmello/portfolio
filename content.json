{"meta":{"title":"Portfolio Calculo Numerico","subtitle":"Métodos numéricos para ajuste de curvas","description":"Este portfólio apresenta as atividades, tarefas e implementações realizadas no âmbito da disciplina de Cálculo Numérico, com foco em métodos numéricos para ajuste de curvas. Inclui explicações detalhadas dos códigos desenvolvidos, interfaces de programação, e exemplos práticos de interpolação e regressão. Este portfólio serve como uma ferramenta de estudo e referência para compreender e aplicar técnicas numéricas em diversos contextos.","author":"Nicolas Mello","url":"https://nickapmello.github.io/portfolio","root":"/portfolio/"},"pages":[],"posts":[{"title":"Lista","slug":"Lista","date":"2024-06-15T03:00:00.000Z","updated":"2024-06-15T06:27:40.572Z","comments":true,"path":"2024/06/15/Lista/","permalink":"https://nickapmello.github.io/portfolio/2024/06/15/Lista/","excerpt":"","text":"Introdução a ListaNa seguinte lista de exercícios, foi proposta a ideia de utilizar os códigos que desenvolvemos em aula para apresentar a solução dos três seguintes exercícios de interpolação. Para cada exercício, deve ser utilizado os métodos de interpolação de Newton e Lagrange. Printando o código demostrando a resposta calculada. Exibição de códigos desenvolvidosMétodo de Newton (Ajustei para pedir quantidade e valor dos pontos)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def calc(x, y): if len(y) == 1: return y[0] else: return (calc(x[1:], y[1:]) - calc(x[:-1], y[:-1])) / (x[-1] - x[0])def polinomio(x, y): n = len(x) coeficientes = [] for i in range(n): coeficientes.append(calc(x[:i + 1], y[:i + 1])) return coeficientesdef calc_polinomio(coeficientes, x, valor): n = len(coeficientes) resultado = coeficientes[0] for i in range(1, n): termo = coeficientes[i] for j in range(i): termo *= (valor - x[j]) resultado += termo return resultadodef interpolacao(x, y, valor): coeficientes = polinomio(x, y) return calc_polinomio(coeficientes, x, valor)def solicitar_pontos(): quantidade_de_pontos = int(input(&quot;Quantos pontos você deseja inserir? &quot;)) pontos_x = [] pontos_y = [] for i in range(quantidade_de_pontos): x = float(input(f&quot;Digite o valor de x_&#123;i&#125;: &quot;)) y = float(input(f&quot;Digite o valor de f(x_&#123;i&#125;): &quot;)) pontos_x.append(x) pontos_y.append(y) return pontos_x, pontos_ydef valor_final(): pontos_x, pontos_y = solicitar_pontos() x_interpolar = float(input(&quot;Digite o valor de x para interpolação: &quot;)) resultado = interpolacao(pontos_x, pontos_y, x_interpolar) print(f&quot;O valor interpolado em x = &#123;x_interpolar&#125; é &#123;resultado:.4f&#125;&quot;)if __name__ == &quot;__valor_final__&quot;: valor_final() Método de Lagrange1234567891011121314151617181920212223242526272829303132333435def calc_polinomio(pontos_x, i, x_interpolar): polinomio_basico = 1 for j in range(len(pontos_x)): if i != j: polinomio_basico *= (x_interpolar - pontos_x[j]) / (pontos_x[i] - pontos_x[j]) return polinomio_basicodef calc_poli_lagrange(pontos_x, pontos_y, x_interpolar): resultado_interpolado = 0 for i in range(len(pontos_x)): L_i = calc_polinomio(pontos_x, i, x_interpolar) resultado_interpolado += pontos_y[i] * L_i return resultado_interpoladodef solicitar_pontos(): quantidade_de_pontos = int(input(&quot;Quantos pontos você deseja inserir? &quot;)) pontos_x = [] pontos_y = [] for i in range(quantidade_de_pontos): x = float(input(f&quot;Digite o valor de x_&#123;i&#125;: &quot;)) y = float(input(f&quot;Digite o valor de f(x_&#123;i&#125;): &quot;)) pontos_x.append(x) pontos_y.append(y) return pontos_x, pontos_ydef valor_final(): pontos_x, pontos_y = solicitar_pontos() x_interpolar = float(input(&quot;Digite o valor de x para interpolação: &quot;)) resultado = calc_poli_lagrange(pontos_x, pontos_y, x_interpolar) print(f&quot;O valor interpolado em x = &#123;x_interpolar&#125; é &#123;resultado&#125;&quot;)if __name__ == &quot;__valor_final__&quot;: valor_final() Exercício 1 Solução com método de Newton: Solução com método de Lagrange: Exercício 2 Solução com método de Newton: Solução com método de Lagrange: Exercício 3 Solução com método de Newton: Solução com método de Lagrange: ConclusãoOs resultados para o exercício 1 são exatamente iguais. Para o exercício 2 são praticamente iguais, com uma pequena diferença decimal de 1820.234375 para 1820.2344. Para o exercício 3 são também praticamente iguais, com uma pequena diferença decimal de 2.5096001157625 para 2.5096. Portanto, é correto dizer que com os testes realizados nessa atividade, ambos os métodos de Newton e Lagrange são eficazes para realizar a interpolação de polinômios, produzindo resultados consistentes. Para mais informações, este é o meu GitHub com os dados corretos:GitHub Nicolas Mello - Portfólio Calculo Numerico.","categories":[],"tags":[{"name":"interpolação","slug":"interpolacao","permalink":"https://nickapmello.github.io/portfolio/tags/interpolacao/"},{"name":"Lagrange","slug":"Lagrange","permalink":"https://nickapmello.github.io/portfolio/tags/Lagrange/"},{"name":"Newton","slug":"Newton","permalink":"https://nickapmello.github.io/portfolio/tags/Newton/"},{"name":"ajuste de curvas","slug":"ajuste-de-curvas","permalink":"https://nickapmello.github.io/portfolio/tags/ajuste-de-curvas/"}]},{"title":"Aula Prática 3","slug":"Aula-Pratica-3","date":"2024-06-03T03:00:00.000Z","updated":"2024-06-15T06:23:14.080Z","comments":true,"path":"2024/06/03/Aula-Pratica-3/","permalink":"https://nickapmello.github.io/portfolio/2024/06/03/Aula-Pratica-3/","excerpt":"","text":"Introdução à Interpolação Polinomial de LagrangeA interpolação de Lagrange é uma técnica matemática utilizada para estimar valores desconhecidos dentro do intervalo de um conjunto de pontos conhecidos. Em muitas aplicações práticas, temos um conjunto de dados discretos e precisamos prever ou estimar valores entre esses pontos. A interpolação de Lagrange constrói um polinômio que passa exatamente por cada ponto dado, sendo uma ferramenta poderosa e flexível para diversas aplicações. Objetivo do CódigoO código desenvolvido para a atividade prática tem como objetivo realizar a interpolação de Lagrange entre vários pontos fornecidos pelo usuário. Ele calcula o valor interpolado usando os polinômios básicos de Lagrange e a soma ponderada dos valores de y nos pontos dados. Abaixo está o código completo seguido de uma explicação detalhada de suas funções: 1234567891011121314151617181920212223242526272829303132333435def calc_polinomio(pontos_x, i, x_interpolar): polinomio_basico = 1 for j in range(len(pontos_x)): if i != j: polinomio_basico *= (x_interpolar - pontos_x[j]) / (pontos_x[i] - pontos_x[j]) return polinomio_basicodef calc_poli_lagrange(pontos_x, pontos_y, x_interpolar): resultado_interpolado = 0 for i in range(len(pontos_x)): L_i = calc_polinomio(pontos_x, i, x_interpolar) resultado_interpolado += pontos_y[i] * L_i return resultado_interpoladodef solicitar_pontos(): quantidade_de_pontos = int(input(&quot;Quantos pontos você deseja inserir? &quot;)) pontos_x = [] pontos_y = [] for i in range(quantidade_de_pontos): x = float(input(f&quot;Digite o valor de x_&#123;i&#125;: &quot;)) y = float(input(f&quot;Digite o valor de f(x_&#123;i&#125;): &quot;)) pontos_x.append(x) pontos_y.append(y) return pontos_x, pontos_ydef valor_final(): pontos_x, pontos_y = solicitar_pontos() x_interpolar = float(input(&quot;Digite o valor de x para interpolação: &quot;)) resultado = calc_poli_lagrange(pontos_x, pontos_y, x_interpolar) print(f&quot;O valor interpolado em x = &#123;x_interpolar&#125; é &#123;resultado&#125;&quot;)if __name__ == &quot;__valor_final__&quot;: valor_final() Explicando o código desenvolvido123456def calc_polinomio(pontos_x, i, x_interpolar): polinomio_basico = 1 for j in range(len(pontos_x)): if i != j: polinomio_basico *= (x_interpolar - pontos_x[j]) / (pontos_x[i] - pontos_x[j]) return polinomio_basico Esta função calcula o polinômio básico de Lagrange Li(x) para um ponto específico ‘i’. O polinômio básico é construído como um produto de frações que dependem dos pontos fornecidos, exceto o ponto ‘i’. Este polinômio é usado para calcular a contribuição de cada ponto yi na interpolação. 123456def calc_poli_lagrange(pontos_x, pontos_y, x_interpolar): resultado_interpolado = 0 for i in range(len(pontos_x)): L_i = calc_polinomio(pontos_x, i, x_interpolar) resultado_interpolado += pontos_y[i] * L_i return resultado_interpolado Esta função calcula o valor interpolado em ‘x’ usando os polinômios básicos de Lagrange. Ela soma as contribuições ponderadas de cada ponto ‘yi’ onde os pesos são os valores dos polinômios básicos calculados na função anterior. 123456789101112def solicitar_pontos(): quantidade_de_pontos = int(input(&quot;Quantos pontos você deseja inserir? &quot;)) pontos_x = [] pontos_y = [] for i in range(quantidade_de_pontos): x = float(input(f&quot;Digite o valor de x_&#123;i&#125;: &quot;)) y = float(input(f&quot;Digite o valor de f(x_&#123;i&#125;): &quot;)) pontos_x.append(x) pontos_y.append(y) return pontos_x, pontos_y Esta função solicita ao usuário que insira a quantidade de pontos e os valores ‘x’ e ‘y’ correspondentes para cada ponto. Os valores são convertidos para ‘float’ para garantir precisão decimal e armazenados em listas. 12345678def valor_final(): pontos_x, pontos_y = solicitar_pontos() x_interpolar = float(input(&quot;Digite o valor de x para interpolação: &quot;)) resultado = calc_poli_lagrange(pontos_x, pontos_y, x_interpolar) print(f&quot;O valor interpolado em x = &#123;x_interpolar&#125; é &#123;resultado&#125;&quot;)if __name__ == &quot;__valor_final__&quot;: valor_final() A função ‘main’ finaliza o código, onde ela chama a função ‘solicitar_pontos’ para obter os pontos fornecidos pelo usuário, também solicita o valor de ‘x’ onde a interpolação deve ser calculada e, em seguida, calcula o valor interpolado usando a função ‘calc_poli_lagrange’. Para mais informações, este é o meu GitHub com os dados corretos:GitHub Nicolas Mello - Portfólio Calculo Numerico.","categories":[],"tags":[{"name":"interpolação","slug":"interpolacao","permalink":"https://nickapmello.github.io/portfolio/tags/interpolacao/"},{"name":"métodos numéricos","slug":"metodos-numericos","permalink":"https://nickapmello.github.io/portfolio/tags/metodos-numericos/"},{"name":"matemática","slug":"matematica","permalink":"https://nickapmello.github.io/portfolio/tags/matematica/"},{"name":"polinômios","slug":"polinomios","permalink":"https://nickapmello.github.io/portfolio/tags/polinomios/"},{"name":"lagrange","slug":"lagrange","permalink":"https://nickapmello.github.io/portfolio/tags/lagrange/"}]},{"title":"Aula Prática 2","slug":"Aula-Pratica-2","date":"2024-06-01T03:00:00.000Z","updated":"2024-06-15T06:23:08.386Z","comments":true,"path":"2024/06/01/Aula-Pratica-2/","permalink":"https://nickapmello.github.io/portfolio/2024/06/01/Aula-Pratica-2/","excerpt":"","text":"Introdução à Interpolação Polinomial de NewtonA interpolação polinomial de Newton é uma técnica matemática utilizada para estimar valores desconhecidos que se encontram dentro do intervalo de um conjunto de pontos conhecidos. Em muitas aplicações práticas, temos um conjunto de dados discretos e precisamos prever ou estimar valores entre esses pontos. A interpolação de Newton é uma forma eficiente de construir polinômios interpoladores que passam exatamente por cada ponto dado. Objetivo do CódigoO código desenvolvido para a atividade prática tem como objetivo realizar a interpolação polinomial de Newton entre vários pontos fornecidos pelo usuário. Ele calcula os coeficientes do polinômio interpolador usando diferenças divididas e, em seguida, usa esses coeficientes para estimar valores intermediários. Abaixo está o código completo seguido de uma explicação detalhada de suas funções: 12345678910111213141516171819202122232425262728293031323334def calc_coeficientes(x, y): if len(y) == 1: return y[0] else: return (calc_coeficientes(x[1:], y[1:]) - calc_coeficientes(x[:-1], y[:-1])) / (x[-1] - x[0])def polinomio(x, y): n = len(x) coeficientes = [] for i in range(n): coeficientes.append(calc_coeficientes(x[:i + 1], y[:i + 1])) return coeficientesdef calc_polinomio(coeficientes, x, valor): n = len(coeficientes) resultado = coeficientes[0] for i in range(1, n): termo = coeficientes[i] for j in range(i): termo *= (valor - x[j]) resultado += termo return resultadodef interpolacao(x, y, valor): coeficientes = polinomio(x, y) return calc_polinomio(coeficientes, x, valor)x_pontos = [1, 2.4, 3, 3.7, 5]y_pontos = [0.6, 1.3, 1.6, 1.9, 1.2]valor_a_interpolar = 4valor_interpolado = interpolacao(x_pontos, y_pontos, valor_a_interpolar)print(f&quot;O valor interpolado em x = &#123;valor_a_interpolar&#125; é &#123;valor_interpolado:.4f&#125;&quot;) Explicando o código desenvolvido12345def calc(x, y): if len(y) == 1: return y[0] else: return (calc(x[1:], y[1:]) - calc(x[:-1], y[:-1])) / (x[-1] - x[0]) Esta função calcula os coeficientes de diferenças divididas recursivamente. A diferença dividida é uma generalização do coeficiente angular usado na interpolação linear, permitindo calcular coeficientes para polinômios de grau superior. Se houver apenas um ponto, a função retorna o valor de y. Caso contrário, calcula a diferença dividida entre os pontos. 1234567def polinomio(x, y): n = len(x) coeficientes = [] for i in range(n): coeficientes.append(calc(x[:i + 1], y[:i + 1])) return coeficientes Esta função usa a função ‘calc’ para calcular os coeficientes do polinômio interpolador de Newton. Ela itera sobre o conjunto de pontos, calculando as diferenças divididas necessárias e armazenando esses coeficientes em uma lista. 123456789def calc_polinomio(coeficientes, x, valor): n = len(coeficientes) resultado = coeficientes[0] for i in range(1, n): termo = coeficientes[i] for j in range(i): termo *= (valor - x[j]) resultado += termo return resultado Esta função avalia o polinômio interpolador em um valor específico usando os coeficientes calculados. Ela aplica o método de Horner para calcular o valor do polinômio de forma eficiente. 1234def interpolacao(x, y, valor): coeficientes = polinomio(x, y) return calc_polinomio(coeficientes, x, valor) A função ‘interpolacao’ coordena o cálculo dos coeficientes e a avaliação do polinômio. Ela primeiro calcula os coeficientes do polinômio interpolador usando a função ‘polinomio’ e, em seguida, avalia o polinômio no valor desejado usando a função ‘calc_polinomio’. 1234567x_pontos = [1, 2.4, 3, 3.7, 5]y_pontos = [0.6, 1.3, 1.6, 1.9, 1.2]valor_a_interpolar = 4valor_interpolado = interpolacao(x_pontos, y_pontos, valor_a_interpolar)print(f&quot;O valor interpolado em x = &#123;valor_a_interpolar&#125; é &#123;valor_interpolado:.4f&#125;&quot;) Este é o final do código, onde são listados 5 específicos valores para os pontos de ‘x’ e para os pontos de ‘y’ e o valor de ‘x’ no qual queremos interpolar de um valor estimado para obter o valor final de ‘y’. Por tanto, o código executa a interpolação para o valor de x especificado ‘valor_a_interpolar’, calculando o valor correspondente de y usando o polinômio interpolador de Newton construído a partir dos pontos fornecidos. Para mais informações, este é o meu GitHub com os dados corretos:GitHub Nicolas Mello - Portfólio Calculo Numerico.","categories":[],"tags":[{"name":"interpolação","slug":"interpolacao","permalink":"https://nickapmello.github.io/portfolio/tags/interpolacao/"},{"name":"métodos numéricos","slug":"metodos-numericos","permalink":"https://nickapmello.github.io/portfolio/tags/metodos-numericos/"},{"name":"matemática","slug":"matematica","permalink":"https://nickapmello.github.io/portfolio/tags/matematica/"},{"name":"polinômios","slug":"polinomios","permalink":"https://nickapmello.github.io/portfolio/tags/polinomios/"},{"name":"newton","slug":"newton","permalink":"https://nickapmello.github.io/portfolio/tags/newton/"}]},{"title":"Aula Prática 1","slug":"Aula-Pratica-1","date":"2024-05-29T03:00:00.000Z","updated":"2024-06-15T06:23:05.443Z","comments":true,"path":"2024/05/29/Aula-Pratica-1/","permalink":"https://nickapmello.github.io/portfolio/2024/05/29/Aula-Pratica-1/","excerpt":"","text":"Introdução à Interpolação LinearA interpolação linear é uma técnica matemática utilizada para estimar valores desconhecidos que se encontram dentro do intervalo de dois pontos conhecidos. Em muitas aplicações práticas, temos um conjunto de dados discretos e precisamos prever ou estimar valores entre esses pontos. A interpolação linear é a forma mais simples de interpolação, e envolve a construção de uma reta que conecta dois pontos dados. Objetivo do CódigoO código desenvolvido para a primeira atividade prática tem como objetivo realizar a interpolação linear entre dois pontos fornecidos pelo usuário. Ele calcula a equação da reta que passa por esses pontos, encontrando os dois coeficientes angulares, a1 e a0, que definem essa reta. A equação da reta é então usada para prever valores intermediários entre os dois pontos.Abaixo está o código completo seguido de uma explicação detalhada de suas funções: 1234567891011121314151617181920212223242526272829303132def coef_angular1(x0, y0, x1, y1): return (y1 - y0) / (x1 - x0)def coef_angular0(a1, x0, y0): return y0 - a1 * x0def pontos(): print(&quot;Insira os valores dos pontos para realizar a interpolação linear.&quot;) x0 = float(input(&quot;Digite o valor de x0: &quot;)) y0 = float(input(&quot;Digite o valor de y0: &quot;)) x1 = float(input(&quot;Digite o valor de x1: &quot;)) y1 = float(input(&quot;Digite o valor de y1: &quot;)) return x0, y0, x1, y1def main(): x0, y0, x1, y1 = pontos() a1 = coef_angular1(x0, y0, x1, y1) a0 = coef_angular0(a1, x0, y0) print(f&quot;Coeficiente a1 = &#123;a1:.3f&#125;&quot;) print(f&quot;Coeficiente a0 = &#123;a0:.3f&#125;&quot;) print(f&quot;P(x) = &#123;a0:.3f&#125; + &#123;a1:.3f&#125;x&quot;)if __name__ == &quot;__main__&quot;: main()# Pontos específicos da aula para teste# x0, y0 = 0.1, 1.221 ; x1, y1 = 0.6, 3.320 Explicando o código desenvolvido12def coef_angular1(x0, y0, x1, y1): return (y1 - y0) / (x1 - x0) Esta função calcula o coeficiente angular a1, que é a inclinação da reta que conecta os dois pontos (x0,y0) e (x1,y1). A inclinação é dada pela razão entre a diferença nas coordenadas y e a diferença nas coordenadas x, sendo: a1 &#x3D; (y1-y0) &#x2F; (x1-x0) 12def coef_angular0(a1, x0, y0): return y0 - a1 * x0 Esta função calcula o coeficiente linear a0, que é o ponto onde a reta intercepta o eixo y. Este coeficiente é calculado rearranjando a equação da reta y &#x3D; a1 * x + a0 para resolver a0, sendo: a0 &#x3D; y0 - a1 * x0 12345678910def pontos(): print(&quot;Insira os valores dos pontos para realizar a interpolação linear.&quot;) x0 = float(input(&quot;Digite o valor de x0: &quot;)) y0 = float(input(&quot;Digite o valor de y0: &quot;)) x1 = float(input(&quot;Digite o valor de x1: &quot;)) y1 = float(input(&quot;Digite o valor de y1: &quot;)) return x0, y0, x1, y1 Esta função solicita ao usuário que insira os valores dos dois pontos necessários para a interpolação linear. Os valores são lidos como entradas do usuário e convertidos para o tipo ‘float’ para garantir precisão decimal. A função retorna os valores dos pontos x0,y0 e x1,y1. Após passar por todos esses processos, o código chama a função ‘pontos’ para obter os valores dos pontos fornecidos pelo usuário, calcula os coeficientes a1 e a0 usando as funções ‘coef_angular1’ e ‘coef_angular0’. Por final, imprime os coeficientes e a equação da reta resultante no formato P(X) &#x3D; a0 + a1 * x. Para mais informações, este é o meu GitHub com os dados corretos:GitHub Nicolas Mello - Portfólio Calculo Numerico.","categories":[],"tags":[{"name":"interpolação","slug":"interpolacao","permalink":"https://nickapmello.github.io/portfolio/tags/interpolacao/"},{"name":"métodos numéricos","slug":"metodos-numericos","permalink":"https://nickapmello.github.io/portfolio/tags/metodos-numericos/"},{"name":"matemática","slug":"matematica","permalink":"https://nickapmello.github.io/portfolio/tags/matematica/"},{"name":"polinômios","slug":"polinomios","permalink":"https://nickapmello.github.io/portfolio/tags/polinomios/"}]}],"categories":[],"tags":[{"name":"interpolação","slug":"interpolacao","permalink":"https://nickapmello.github.io/portfolio/tags/interpolacao/"},{"name":"Lagrange","slug":"Lagrange","permalink":"https://nickapmello.github.io/portfolio/tags/Lagrange/"},{"name":"Newton","slug":"Newton","permalink":"https://nickapmello.github.io/portfolio/tags/Newton/"},{"name":"ajuste de curvas","slug":"ajuste-de-curvas","permalink":"https://nickapmello.github.io/portfolio/tags/ajuste-de-curvas/"},{"name":"métodos numéricos","slug":"metodos-numericos","permalink":"https://nickapmello.github.io/portfolio/tags/metodos-numericos/"},{"name":"matemática","slug":"matematica","permalink":"https://nickapmello.github.io/portfolio/tags/matematica/"},{"name":"polinômios","slug":"polinomios","permalink":"https://nickapmello.github.io/portfolio/tags/polinomios/"},{"name":"lagrange","slug":"lagrange","permalink":"https://nickapmello.github.io/portfolio/tags/lagrange/"},{"name":"newton","slug":"newton","permalink":"https://nickapmello.github.io/portfolio/tags/newton/"}]}